#!/bin/bash

# some more ls aliases
alias ll='ls -lh'
alias la='ls -A'
alias l='ls -CF'
alias emacs='emacs -nw'
# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

### Filesystem Aliases ###
mkcd() { mkdir $1 ;  cd $1 ; }
rmdir  () { rm -rf "$@" ;       }
follow () { cp $1 $2 ; cd $2 ;  }

# list of files in the current directory
# modified #1 hours or sooner
ls-time() {

    if [ "$1" == "-h" ]; then
        echo "Usage: ls-time <ls_flags> <directory> <hrs>"
        return
    fi

    t=$(echo "${@: -1} / 24.0" | bc -l)

    if [ $# -gt 1 ]; then
        ls_flags=$1
    else
        ls_flags=""
    fi

    files=$(find "${@:(-2):1}" -maxdepth 1 -type f -mtime -$t -print0)
    if [ ! -z "$files" ] ; then
        echo -n $files | xargs -0 ls $ls_flags
    fi
}

dawn_connect() { tmux new -n dawn-connection -d "ssh -L 8888:localhost:8888 dawn"; }

grepall (){ grep -rn $1 ./* --color=always; }

machine_config () { source ~/.bash/machines/machinesrc ; emacs -nw ~/.bash/machines/$MACHINE_NAME; }

# tmux aliases
alias ta='tmux attach'

# git Aliases #
list_authors='git log --format='%aN' | sort -u'
alias gs='git status'
alias gpo='git push origin'
alias gpu='git push upstream'
alias gfo='git fetch origin'
alias gfu='git fetch upstream'
alias gt='cd $(git rev-parse --show-toplevel)'
alias git-clean-reset='git reset --hard HEAD && git clean -dxf'

ghpr() {
  set -euo pipefail

  if ! command -v gh >/dev/null 2>&1; then
    echo "ghpr: GitHub CLI (gh) is not installed" >&2
    return 127
  fi

  if ! command -v git >/dev/null 2>&1; then
    echo "ghpr: git is not installed" >&2
    return 127
  fi

  if [ $# -lt 1 ]; then
    echo "usage: ghpr <PR_NUMBER|PR_URL> [-- <extra args to gh pr checkout>]" >&2
    return 2
  fi

  pr="$1"
  shift || true

  # Allow passing extra args to gh pr checkout after --
  extra_args=()
  if [ "${1:-}" = "--" ]; then
    shift
    extra_args=("$@")
  fi

  # Checkout via gh (creates/switches local branch)
  gh pr checkout "$pr" "${extra_args[@]}"

  # Query PR head info
  # NOTE: headRepository is the contributor fork repo; headRefName is the contributor branch name
  head_owner="$(gh pr view "$pr" --json headRepositoryOwner --jq '.headRepositoryOwner.login')"
  head_name="$(gh pr view "$pr" --json headRepository --jq '.headRepository.name')"
  head_ref="$(gh pr view "$pr" --json headRefName --jq '.headRefName')"
  head_ssh="$(gh pr view "$pr" --json headRepository --jq '.headRepository.sshUrl')"
  head_https="$(gh pr view "$pr" --json headRepository --jq '.headRepository.url')"

  # If for some reason sshUrl isn't available, fall back to https
  remote_url="$head_ssh"
  if [ -z "$remote_url" ] || [ "$remote_url" = "null" ]; then
    remote_url="$head_https"
  fi

  if [ -z "$remote_url" ] || [ "$remote_url" = "null" ]; then
    echo "ghpr: could not determine head repo URL for PR '$pr'" >&2
    return 1
  fi

  # Choose a remote name based on contributor login (e.g., "octocat")
  base_remote="$head_owner"
  remote="$base_remote"

  # If remote exists, check whether it already points to this fork; otherwise find a free suffix
  if git remote get-url "$remote" >/dev/null 2>&1; then
    existing="$(git remote get-url "$remote")"
    if [ "$existing" != "$remote_url" ]; then
      i=2
      while git remote get-url "${base_remote}-${i}" >/dev/null 2>&1; do
        existing_i="$(git remote get-url "${base_remote}-${i}")"
        if [ "$existing_i" = "$remote_url" ]; then
          remote="${base_remote}-${i}"
          break
        fi
        i=$((i+1))
      done
      if [ "$remote" = "$base_remote" ]; then
        remote="${base_remote}-${i}"
      fi
    fi
  fi

  # Add remote if missing
  if ! git remote get-url "$remote" >/dev/null 2>&1; then
    echo "Adding contributor remote '$remote' -> $remote_url"
    git remote add "$remote" "$remote_url"
  else
    # Keep URL current if it matches the same fork; if it differs we handled via suffix above
    true
  fi

  # Fetch the contributor remote
  git fetch "$remote" --prune

  # If current branch is tracking something else, don't stomp it.
  # But if it has no upstream, set upstream to contributor branch (useful for pushing fixes to their fork)
  cur_branch="$(git branch --show-current)"
  if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
    # Only set upstream if the branch exists on the contributor remote (it should)
    if git show-ref --verify --quiet "refs/remotes/$remote/$head_ref"; then
      git branch --set-upstream-to="$remote/$head_ref" "$cur_branch" >/dev/null 2>&1 || true
    fi
  fi

  echo "Done. Contributor fork remote: $remote (branch: $head_ref)"
}


# external ip alias #
alias wanip='dig +short myip.opendns.com @resolver1.opendns.com'

# make system aliases #
alias cb='make clean; make -j8'
alias cbi='make clean; make -j8 && make install'
alias cbc='make clean && make -j 8 && make -j 8 check'
alias cbt='make clean && make -j 8 && make test'
alias ch='make -j 8 check'
alias bci='make -j8 check && make -j8 install'
alias bi='make -j8 install'
alias bi='make -j8 all install t'

# gnome desktop aliases #
alias gdm-restart='/etc/init.d/gdm3 restart'

#########################################
### Mount/UnMount remote directories ####
#########################################
function remmnt {

    if [ "$#" -eq 2 -o "$#" -gt 3 ]
    then
	echo "Function is designed for 1 or 3 arguments."
	return 1
    fi

    if [ "$#" -gt 2 ]
    then
	if [ "$2" != "as" ]
	then
	    echo "Please use the following format to set remote filesystems: "
	    echo "remmnt <hostname> as <desired_name>"
	    return 1
	fi
	echo "Using third argument to set directory name."
	if [ ! -d ~/mnt/$3 ]; then mkdir -p ~/mnt/$3; fi
	if [ "$(ls -A ~/mnt/$3)" ]; then echo "Destination directory is not empty. Exiting..." ; exit 1; fi
	sshfs -oauto_cache,reconnect $1:/home/ ~/mnt/$3
	if [ $? -ne 0 ]; then echo "Mount failed. Removing intended destination directory..."; rmdir ~/mnt/$3; fi
    else
	if [ ! -d ~/mnt/$1 ]; then mkdir -p ~/mnt/$1; fi
	if [ "$(ls -A ~/mnt/$1)" ]; then echo "Destination directory is not empty. Exiting..." ; exit 1; fi
	sshfs -oauto_cache,reconnect $1:/home/ ~/mnt/$1
	if [ $? -ne 0 ]; then echo "Mount failed. Removing intended destination directory..."; rmdir ~/mnt/$1; fi
    fi
}

function remumnt () {
    if fusermount -u ~/mnt/$1; then
	rmdir ~/mnt/$1
    else
	if [ "$(ls -A ~/mnt/$1)" ] ; then
	    echo "Could not unmount. Files exist in directory. Please investigate further."
	else
	    read -p "Could not unmount. Directory is empty. Remove dir? [y/n] " -n 1 -r
	    echo
	    if [[ $REPLY =~ ^[Yy]$ ]]; then
		rmdir ~/mnt/$1
	    fi
	fi
    fi
}

#### End Mount Section ###

#########
# MEDIA #
#########

### Pandora Stuff (relies on pianobar) ###
function pandora() {

#check to see if a pandora tmux session is already in existence
if [ 0 -eq "$(tmux list-sessions | grep pandora | wc -l )" ] ; then
    #create a pandora tmux and enter it
    echo "Creating tmux for pandora..."
    tmux new -s pandora pianobar
else
    echo "Entering pandora..."
    tmux a -t pandora
fi

}

### mps-youtube Stuff (relies on pianobar) ###
function tunes() {

#check to see if a mpsyt tmux session is already in existence
if [ 0 -eq "$(tmux list-sessions | grep music | wc -l )" ] ; then
    #create a mpsyt tmux and enter it
    echo "Creating tmux for music player..."
    tmux new -s music music-player
else
    tmux a -t music
fi

}


function pnext () { tmux send -t music n;}

function ppause() { tmux send -t music p; }

function pquit () { tmux send -t music q; tmux send -t music "exit"; tmux send -t music "Enter"; }

function pplay () { tmux send -t music p; }


function set-title() {
  TITLE="\033];$*\007"
  echo -e ${TITLE}
}

##########################
### ADD DOCKER ALIASES ###
##########################

function doccker-rm-all() {
    while true; do
        read -p "Warning!! This will remove all docker images. Proceed? [y/n] " yn
        case $yn in
            [y] ) echo "Installing common Ubuntu packages for dev."; \
                  docker container prune && docker image prune -a
                  break;;
            [n] ) echo "Ok."; exit;;
            * ) echo "Please enter y or n.";;
        esac
    done
}

function docker-clean() {
    docker image prune -a
    docker container prune
}

function delayed_cmd() {
    pid=$(exec sh -c 'echo "$PPID"')
    sleep $1
    notify-send "$pid: Executing command '$2' after $3"
    sleep $3
    eval $2
    notify-send "Delayed Command '$2' executed"
}

export EDITOR='emacs -nw'

################################
# Git stuff #
################################
export GIT_EDITOR='emacs -nw'
source $HOME/.bash/common/worktreerc

################################
# CUSTOM SCRIPTS & EXECUTABLES #
################################
export PATH=$HOME/.local/bin:$PATH
export PATH=$HOME/.bash/bin:$PATH


#######################
### ADD SSH ALIASES ###
#######################
source $HOME/.bash/ssh/ssh_aliases

###################################
# MACHINE SPECIFIC CONFIGURATIONS #
###################################
source $HOME/.bash/machines/machinesrc

##################################
# CHECK CONFIGURATION UP TO DATE #
##################################
($HOME/.bash/common/check_config &)
